package secrets

import (
	"bytes"
	"errors"
	"fmt"
	"io/ioutil"
	"os"
	"sync"

	"github.com/sourcegraph/sourcegraph/internal/conf"
)

var defaultEncryptor encryptorObject
var configuredToEncrypt bool

const (
	// #nosec G101
	sourcegraphSecretfileEnvvar = "SOURCEGRAPH_SECRET_FILE"
	sourcegraphCryptEnvvar      = "SOURCEGRAPH_CRYPT_KEY"
)

// gatherKeys splits the encryption string into its potential two components
func gatherKeys(data []byte) (oldKey, newKey []byte) {
	parts := bytes.Split(data, []byte(","))
	if len(parts) > 2 {
		panic("no more than two encryption keys should be specified.")
	}
	if len(parts) == 1 {
		return parts[0], nil
	}

	return parts[0], parts[1]
}

var initErr error
var initOnce sync.Once

// Init creates the defaultEncryptor by ingesting user encryption key(s).
// For production deployments, the secret value CAN ONLY be generated by the user and loaded via a file or env var.
// For single server docker deployments, we will generate the secret file and write it to disk.
func Init() error {
	initOnce.Do(func() {
		initErr = initDefaultEncryptor()
	})
	return initErr
}

func initDefaultEncryptor() error {
	configuredToEncrypt = false

	var encryptionKey []byte

	// set the default location if none exists
	secretFile := os.Getenv(sourcegraphSecretfileEnvvar)
	if secretFile == "" {
		// #nosec G101
		secretFile = "/var/lib/sourcegraph/token"
	}

	// reading from a file is first order
	fileInfo, err := os.Stat(secretFile)
	if err == nil {
		perm := fileInfo.Mode().Perm()
		if perm != os.FileMode(0400) {
			return errors.New("encryption key file is not 0400")
		}

		contents, readErr := ioutil.ReadFile(secretFile)
		if readErr != nil {
			panic(fmt.Sprintf("couldn't read file %s", sourcegraphSecretfileEnvvar))
		}
		if len(contents) < validKeyLength {
			panic(fmt.Sprintf("key length of %d characters is required.", validKeyLength))
		}
		encryptionKey = contents

		newKey, oldKey := gatherKeys(encryptionKey)

		defaultEncryptor.primary = newKey
		defaultEncryptor.secondary = oldKey
		configuredToEncrypt = true
		return nil
	}

	envCryptKey, cryptOK := os.LookupEnv(sourcegraphCryptEnvvar)
	// environment is second order
	if cryptOK {
		if len(envCryptKey) != validKeyLength {
			panic(fmt.Sprintf("encryption key must be %d characters", validKeyLength))
		}
		newKey, oldKey := gatherKeys(encryptionKey)
		defaultEncryptor.primary = newKey
		defaultEncryptor.secondary = oldKey
		configuredToEncrypt = true
		return nil
	}

	// for the single docker case, we generate the secret
	deployType := conf.DeployType()
	if conf.IsDeployTypeSingleDockerContainer(deployType) {
		b, err := GenerateRandomAESKey()
		if err != nil {
			panic(fmt.Sprintf("unable to read from random source: %v", err))
		}
		err = ioutil.WriteFile(secretFile, b, 0600)
		if err != nil {
			panic(err)
		}

		err = os.Chmod(secretFile, 0400)
		if err != nil {
			panic("failed to make secrets file read only.")
		}
		newKey, _ := gatherKeys(b)
		defaultEncryptor.primary = newKey
		configuredToEncrypt = true
		return nil
	}

	// wrapping in deploytype check so that we can still compile and test locally
	if os.Getenv("CI") != "" || conf.IsDev(deployType) {
		return nil
	} else {
		// for k8s & docker compose, expect a secret to be provided
		panic(fmt.Sprintf("Either specify environment variable %s or provide the secrets file %s.",
			sourcegraphCryptEnvvar,
			sourcegraphSecretfileEnvvar))
	}
}
